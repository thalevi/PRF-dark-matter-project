%!TEX root = ../main.tex

\newcommand{\aux}{\textsf{aux}}
\newcommand{\seed}{\textsf{seed}}
\newcommand{\msgs}{\textsf{msgs}}
\newcommand{\algcomment}[1]{{\color{Gray}{\qquad//#1}}}

\section{Applications}
\label{sec:applications}

\subsection{A Signature Scheme}
Here we describe a signature scheme using the (2,3)-OWF.  Abstractly, a
signature scheme can be built from any OWF that has an MPC protocol to
evaluatue it, by setting the public key to $y = F(x)$ for a random secret $x$,
and then proving knowledge of $x$, using a proof system based on the
MPC-in-the-head paradigm~\cite{STOC:IKOS07}.  In addition to assuming the OWF is
secure, the only other assumption require is a secure hash function. As 
no additional number theoretic assumptions are required, these type of signatures are
often proposed as secure post-quantum schemes. 

Concretely, our design follows the Picnic signature scheme~\cite{CCS:CDGORR17},
specifically the variant instantiated with the KKW proof
system~\cite{CCS:KatKolWan18} (named Picnic2 and Picnic3).  We chose to use the
KKW, rather than ZKB++ proof system since our MPC protocol to evaluate the
(2,3)-OWF is most efficient with a pre-processing phase, and KKW generally
produces shorter signatures.  We replace the OWF in Picnic, the LowMC block cipher~\cite{EC:ARSTZ15}, 
with the (2,3)-OWF, and make the corresponding changes to the MPC protocol. 

\greg{Need some motivation here for why this is interesting. Rough ideas: 
\begin{itemize}
\item No existing
signature scheme based on the (2,3)-OWF or similar assumption.  
\item Alternative
structure of the (2,3)-OWF may be easier to analyze than LowMC, which follows a
more traditional block cipher design.  
\item The (2,3)-OWF is conceptually much simpler
requires far less precomputed constants, and has a simpler implementation. 
\item Potential advantages in implementation performance
\end{itemize} }

\paragraph{Notation}
Recall that the OWF is defined as, $y = F(x)$ where $x \in \Z_2^{n}$ and $y\in \Z_3^{t}$. 
\begin{enumerate}
\item Compute $w = Ax \in \Z_2^{m}$, where $A$ is a public, randomly chosen matrix of full rank in $\Z_2^{m\times n}$
\item Let $z\in\Z_3^{m}$ be $w$ intepreted mod 3
\item Compute and output $y = Gz$, where $G \in \Z_3^{m\times t}$ is randomly chosen as $A$ was. 
\end{enumerate}


\paragraph{An $N$-party protocol}
There will be $N$ parties for our MPC protocol, each holding a secret share of
$x$, who jointly compute $y = F(x)$.  The protocol is $N$-private, meaning that
up to $N-1$ parties may be malicious, and the secret input remains private.
Put another way, given the views of $N-1$ parties we can simulate the remaining
party's view, to prove that the $N-1$ parties have no information about the
remaining party's share. 

The preprocessing phase is similar to that in Picnic.  Each party has a random
tape that they can use to sample a secret sharing of a uniformly random value
(e.g.,  a scalar, vector, or a matrix with terms in $\Z_2$ or $\Z_3$).  Each
party samples their share $[r]$ and the shared value is implicitly defined as
$r = \sum_{i=1}^N [r]_i$.  We use $[r]_i$ to denote party $i$'s share of $r$,
or simply $[r]$ when the context makes the party's index clear.

We must also be able to create a sharing mod 3, of a secret shared value mod 2.
Let $s\in\Z_2$ be secret shared.  Then to establish shares of $r_0 = s \pmod
3$, the first $N-1$ parties sample a share $[r_0]$ from their random tapes. The
$N$-th party's share is chosen by the prover, so that the sum of the shares is
$r_0$.  We refer to the last party's share as an \emph{auxiliary value}, since
it's provided by the prover as part of pre-processing.  For efficiency, party $i$'s
random tape is generated by a random seed, denoted $\seed_i$, using a PRG. The state of the first
$N-1$ parties after pre-processing is a seed value used to generate the random
tape, and for the $N$-th party the state is the seed value plus the list of
auxiliary values, denoted $\aux$. 

After pre-processing, the parties enter the \emph{online} phase of the protocol. 
The prover computes $x'= x + R_x$, where $R_x$ is a random value, established during
preprocessing so that each party's tape has a share $[R_x]$. 
The parties can then compute the OWF using the homomorphic properties of the secret sharing, 
and the a share conversion gadget (to convert shares mod 2 to mod 3, when computing $z$)
setup during preprocessing that we describe below. 
During the online phase, parties broadcast values to all other parties, denote party $i$'s broadcast
messages by $\msgs_i$. 

\subsubsection{MPC protocol details}

\paragraph{Preprocessing phase} Preprocessing establishes random seeds of all parties and shares of 
\begin{enumerate}
\item $R_x$: a random vector in $\Z_2^{n}$,\algcomment{Sampled from random tapes}
\item $R_w$: a random vector in $\Z_2^{m}$, \algcomment{Sampled from random tapes}
\item $r_0$: a sharing of $R_w \pmod 3$, shares in $\Z_3^m$,  \algcomment{Tapes + one $\aux$ value}
\item $r_1$: a sharing of $1-R_w \pmod 3$, shares in $\Z_3^m$. \algcomment{Computed from $r_0$}
\end{enumerate}
The shares of $r_1$ are computed from shares of $r_0$ as follows (all arithmetic in $\Z_3^m$): the first
party computes $[r_1] = 1 - [r_0]$, then the remaining parties compute
$[r_1] = -[r_0]$.  Then observe that 
\[\sum_{i=1}^N [r_1]_i = 1-[r_0]_1 - \ldots - [r_0]_N = 1-r_0 \]
 as required. 

\paragraph{Online phase}
The public input to the online phase is $x' = x + R_x$. 
\begin{enumerate}
\item The parties locally compute $[u] = A[R_x] - [s]$ and broadcast it, 
then sum the received values to get $u = AR_x - s$.  Then they compute
$w' = Ax' - u = Ax + s$, where $w' \in \Z_2^{m}$. Each party broadcasts $m$ bits in this step. 
\item Let $z$ be a vector in $\Z_3^m$ and let $z_i$ denote the $i$-th component. Each party defines 
\[
    [z_i]  = \begin{cases}
                [r_0] = [(R_w)_i] & \text{if $w_i' = 0$} \\
                [r_1] = [1-(R_w)_i] & \text{if $w_i' = 1$} \\
            \end{cases}
\]
then localy computes $[y] = G[z]$. All parties broadcast $[y]$ and reconstruct the output $y\in\Z_{3}^t$. 
In this step each party broadcasts $t$ values in $\Z_3$.
\end{enumerate}

\greg{\paragraph{Possible optimization} (not sure about this yet, getting late
here ;)). Trying to avoid communicating the MPC inputs $x' = x + R_x$. 
  Instead of computing $w' = Ax + s$ from $x' = x + R_x$, can we just
have the parties compute $[w'] = A[v] + [s]$, where $[v]$ are random shares
from the tapes.  This gives $w'= Av + \aux + \sum_{i=1}^{N-1}[s]_{i} $ and the
prover knows all values so he can choose $\aux$ such that $w' = Ax + s$ as
required. However, now preprocessing depends on the witness, so now we can't
cut-and-choose to ensure that $\aux$ is correct (as in KKW).  But if the prover
just ``injects'' $\aux$ in this way, can we check it's corect in some other
way?  This was our approach in the Banquet scheme.  One direction: For two
repetitions, $w_1' - w_2' = s_1 - s_2$ (since $Ax$ is fixed) and $s_1-s_2$ is
linear and must be consistent with the seeds/tapes.
}

\paragraph{Communication Costs}
Here we quantify the cost of communication for the $\aux$ values and the broadcast $\msgs$ of one party,
as this will directly contribute to the signature size in the following section. 
Let $\ell_3$ be the bitlength of an element in $\Z_3$; the direct encoding has
$\ell_3 = 2$, but with compression we can reudce $\ell_3$ to as little as
$\log_2(3) \approx 1.58$. \greg{TODO: crossref.  I'm assuming the details of
this will be somewhere in the paper? I don't know them :)}   The size of the
$\aux$ information is $m\ell_3$, the MPC input value has size $n$ bits, 
and the broadcast values have size $m + t\ell_3$ bits (per party). 
The total is thus 
\[\textsf{size(MPC)} = m(\ell_3 + 1) + n + t\ell_3 \]
which is $2.58m + n + 1.58t$ when $\ell_3 = 1.58$. 
For the parameters $(n,m,t) = (256, 256, 81)$ the total is 1045 bits and for
$(n,m,t)=(128, 400, 81)$ the total is 1288 bits.  This compares favorably to
Picnic at the same security level, which communicates 1032 bits for the $\aux$
and $\msgs$ when LowMC is uses a full S-box layer, and 1200 bits when LowMC
uses a partial S-box layer~\cite{TCHES:KalZav20}. 

\subsubsection{Signature Scheme Details}
\greg{WIP: just some rough notes for discussion on our Wed call}

OWF vs. PRF: for the OWF I don't think there is any performance advantage to
choosing defining compressed matrices (circulant matrices). So better to use
fully random ones. 

The parameters above, for $(256,256,81)$ come from Itai's document, in the wPRF
section.  If they're secure for the wPRF they should also be secure for the
OWF, since the OWF security is required for wPRF security. But we need to
confirm with Itai these are OK.  

Key generation: Choose random $x$ as a secret key, and a seed $s_A$ such that
$s_A$ expands to a matrix $A$ that is full rank.  We use a unique $A$ per
signer in order to avoid multi-target attacks against $F$. Compute $y = F(x)$
and set $(y, s_A)$ as the public key. 

The rest of this section briefly recalls KKW, explains that we choose
parameters ($(M, N, \tau)$ the number of MPC instances $M$, the number of
parties $N$, and the number of online instances $\tau$) in the same way as
Picncic, shows the signature size formula (given $(M, N, \tau)$) and gives some
concrete example siganture sizes at the L1 level. 

Optionally we may compare the NIST L5 level (AES-256 equivalent, i.e., 256-bit
classical, 128-bit quantum secure), in case the security of the (2,3)-OWF
scales better than LowMC. 



\subsection{Distributed Picnic}
\greg{Still no good ideas on how to do this}
