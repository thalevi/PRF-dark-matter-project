%!TEX root = ../main.tex

\newcommand{\aux}{\textsf{aux}}
\newcommand{\com}{\textsf{com}}
\newcommand{\CCC}{\mathcal{C}}
\newcommand{\PPP}{\mathcal{P}}
\newcommand{\ch}{\textsf{ch}}
\newcommand{\hash}{\textsf{H}}
\newcommand{\state}{\textsf{state}}
\newcommand{\seed}{\textsf{seed}}
\newcommand{\msgs}{\textsf{msgs}}
\newcommand{\Msg}{\textsf{Msg}}
\newcommand{\Expand}{\textsf{Msg}}
\newcommand{\algcomment}[1]{{\color{Gray}{\qquad//#1}}}

 \newtcolorbox{titlebox}[5]{
    enhanced,
    colframe=black,
    colback=white,
    boxrule={#3},
    arc={#2},
    auto outer arc,%
%   breakable,
    pad at break*=0pt,
    vfill before first,
    before={\par\medskip\noindent},
    after={\par\medskip},
    top=12pt, left=4pt, enlarge top by=7pt,%enlarge bottom by=7pt,%
    title={\rule[-.3\baselineskip]{0pt}{\baselineskip}\normalsize\sffamily\bfseries #1}, 
    varwidth boxed title*=-30pt, 
    attach boxed title to top left={yshift=-10pt,xshift=10pt}, 
    coltitle=black,
    boxed title style={colback=white,boxrule={#5},arc={#4},auto outer arc}
 }

 \newenvironment{systembox}[1]
 {\vspace{\baselineskip}\begin{titlebox}{Functionality \normalfont #1}{2.5pt}{1pt}{3.5pt}{1pt}}
 {\end{titlebox}}

 \newenvironment{protocolbox}[1]
 {\begin{titlebox}{ #1}{0.5pt}{0.5pt}{1pt}{0.75pt}}
 {\end{titlebox}}

\section{Applications}
\label{sec:applications}

\subsection{A Signature Scheme}
Here we describe a signature scheme using the (2,3)-OWF.  Abstractly, a
signature scheme can be built from any OWF that has an MPC protocol to
evaluatue it, by setting the public key to $y = F(x)$ for a random secret $x$,
and then proving knowledge of $x$, using a proof system based on the
MPC-in-the-head paradigm~\cite{STOC:IKOS07}.  In addition to assuming the OWF is
secure, the only other assumption require is a secure hash function. As 
no additional number theoretic assumptions are required, these type of signatures are
often proposed as secure post-quantum schemes. 

Concretely, our design follows the Picnic signature scheme~\cite{CCS:CDGORR17},
specifically the variant instantiated with the KKW proof
system~\cite{CCS:KatKolWan18} (named Picnic2 and Picnic3).  We chose to use the
KKW, rather than ZKB++ proof system since our MPC protocol to evaluate the
(2,3)-OWF is most efficient with a pre-processing phase, and KKW generally
produces shorter signatures.  We replace the OWF in Picnic, the LowMC block cipher~\cite{EC:ARSTZ15}, 
with the (2,3)-OWF, and make the corresponding changes to the MPC protocol. 

\greg{Need some motivation here for why this is interesting. Rough ideas: 
\begin{itemize}
\item No existing
signature scheme based on the (2,3)-OWF or similar assumption.  
\item Alternative
structure of the (2,3)-OWF may be easier to analyze than LowMC, which follows a
more traditional block cipher design.  
\item The (2,3)-OWF is conceptually much simpler
requires far less precomputed constants, and has a simpler implementation. 
\item Potential advantages in implementation performance
\end{itemize} }

\paragraph{OWF Description}
Recall that the OWF is defined as $y = F(x)$ where $x \in \Z_2^{n}$ and $y\in \Z_3^{t}$, and is computed as follows: 
\begin{enumerate}
\item Compute $w = Ax \in \Z_2^{m}$, where $A$ is a public, randomly chosen matrix of full rank in $\Z_2^{m\times n}$
\item Let $z\in\Z_3^{m}$ be $w$, where entries are intepreted as values mod 3
\item Compute and output $y = Gz$, where $G \in \Z_3^{m\times t}$ is public and randomly chosen as $A$ was. 
\end{enumerate}


\paragraph{An $N$-party protocol}
There will be $N$ parties for our MPC protocol, each holding a secret share of
$x$, who jointly compute $y = F(x)$.  The protocol is $N$-private, meaning that
up to $N-1$ parties may be malicious, and the secret input remains private.
Put another way, given the views of $N-1$ parties we can simulate the remaining
party's view, to prove that the $N-1$ parties have no information about the
remaining party's share. 

The preprocessing phase is similar to that in Picnic.  Each party has a random
tape that they can use to sample a secret sharing of a uniformly random value
(e.g.,  a scalar, vector, or a matrix with terms in $\Z_2$ or $\Z_3$).  Each
party samples their share $[r]$ and the shared value is implicitly defined as
$r = \sum_{i=1}^N [r]_i$.  We use $[r]_i$ to denote party $i$'s share of $r$,
or simply $[r]$ when the context makes the party's index clear.

We must also be able to create a sharing mod 3, of a secret shared value mod 2.
Let $w'\in\Z_2$ be secret shared.  Then to establish shares of $r = w' \pmod
3$, the first $N-1$ parties sample a share $[r]$ from their random tapes. The
$N$-th party's share is chosen by the prover, so that the sum of the shares is
$r$.  We refer to the last party's share as an \emph{auxiliary value}, since
it's provided by the prover as part of pre-processing.  For efficiency, the random
tape for  party $i$ is
generated by a random seed, denoted $\seed_i$, using a PRG. The state of the first
$N-1$ parties after pre-processing is a seed value used to generate the random
tape, and for the $N$-th party the state is the seed value plus the list of
auxiliary values, denoted $\aux$. 

After pre-processing, the parties enter the \emph{online} phase of the protocol. 
The prover computes $\hat{x}= x + x'$, where $x'$ is a random value, established during
preprocessing so that each party has a share $[x']$. 
The parties can then compute the OWF using the homomorphic properties of the secret sharing, 
and a share conversion gadget (to convert shares mod 2 to mod 3, used when computing $z$)
setup during preprocessing that we describe below. 
During the online phase, parties broadcast values to all other parties and we write $\msgs_i$
to denote the broadcast messages of party $i$. 

\subsubsection{MPC protocol details}

\paragraph{Preprocessing phase} Preprocessing establishes random seeds of all parties and shares of 
\begin{enumerate}
\item $x'$: a random vector in $\Z_2^{n}$,\algcomment{Sampled from random tapes}
\item $w'$: a random vector in $\Z_2^{m}$, \algcomment{Sampled from random tapes}
\item $r$: a sharing of $w' \mod 3$, shares in $\Z_3^m$,  \algcomment{Tapes + one $\aux$ value}
\item $\overline{r}$: a sharing of $1-w' \mod 3$, shares in $\Z_3^m$. \algcomment{Computed from shares of $r$}
\end{enumerate}
The shares of $\overline{r}$ are computed from shares of $r$ as follows (all arithmetic in $\Z_3^m$): the first
party computes $[\overline{r}] = 1 - [r]$, then the remaining parties compute
$[\overline{r}] = -[r]$.  Then observe that 
\[\sum_{i=1}^N [\overline{r}]_i = 1-[r]_1 - \ldots - [r]_N = 1 - \sum_{i=1}^{N}[r]_i = 1-r \]
 as required. 

\paragraph{Online phase}
The public input to the online phase is $\hat{x} = x + x'$. 
\begin{enumerate}

\item The parties locally compute $[u] = A[x'] - [w']$ and broadcast it, 
then sum the received values to get $u = Ax' - w'$.  Then they locally compute
$\hat{w} = A\hat{x} - u = Ax + w'$, where $\hat{w} \in \Z_2^{m}$. Each party broadcasts $m$ bits in this step. 

\item Let $z$ be a vector in $\Z_3^m$ and let $z_i$ denote the $i$-th component. Each party defines 
\[
    [z_i]  = \begin{cases}
                [r_i]  & \text{if $\hat{w}_i = 0$} \algcomment{\text{Note that $[r_i] = [w_i']$}}\\
                [\overline{r}_i]  & \text{if $\hat{w}_i = 1$} \algcomment{\text{Note that $[\overline{r}_i] = [1- w_i']$}}\\
            \end{cases}
\]
then localy computes $[y] = G[z]$. All parties broadcast $[y]$ and reconstruct the output $y\in\Z_{3}^t$. 
In this step each party broadcasts $t$ values in $\Z_3$.
\end{enumerate}

\paragraph{Correctness} The protocol correctly computes the (2,3)-OWF. \greg{TODO: explain why this works correctly}

\greg{\paragraph{Possible optimization} (not sure about this yet, getting late
here ;)). Trying to avoid communicating the MPC inputs $x' = x + R_x$. 
  Instead of computing $w' = Ax + s$ from $x' = x + R_x$, can we just
have the parties compute $[w'] = A[v] + [s]$, where $[v]$ are random shares
from the tapes.  This gives $w'= Av + \aux + \sum_{i=1}^{N-1}[s]_{i} $ and the
prover knows all values so he can choose $\aux$ such that $w' = Ax + s$ as
required. However, now preprocessing depends on the witness, so now we can't
cut-and-choose to ensure that $\aux$ is correct (as in KKW).  But if the prover
just ``injects'' $\aux$ in this way, can we check it's corect in some other
way?  This was our approach in the Banquet scheme.  One direction: For two
repetitions, $w_1' - w_2' = s_1 - s_2$ (since $Ax$ is fixed) and $s_1-s_2$ is
linear and must be consistent with the seeds/tapes.
}

\paragraph{Communication Costs}
Here we quantify the cost of communication for the $\aux$ values and the broadcast $\msgs$ of one party,
as this will directly contribute to the signature size in the following section. 
Let $\ell_3$ be the bitlength of an element in $\Z_3$; the direct encoding has
$\ell_3 = 2$, but with compression we can reudce $\ell_3$ to as little as
$\log_2(3) \approx 1.58$. \greg{TODO: crossref.  I'm assuming the details of
this will be somewhere in the paper? I don't know them :)}   The size of the
$\aux$ information is $m\ell_3$, the MPC input value has size $n$ bits, 
and the broadcast values have size $m + t\ell_3$ bits (per party). 
The total is thus 
\[\textsf{size(MPC)} = m(\ell_3 + 1) + n + t\ell_3 \]
which is $2.58m + n + 1.58t$ when $\ell_3 = 1.58$. 
For the parameters $(n,m,t) = (256, 256, 81)$ the total is 1045 bits for
$(n,m,t) = (256, 256, 160)$ the total is 1170 bits, and for
$(n,m,t)=(128, 400, 81)$ the total is 1288 bits.  This compares favorably to
Picnic at the same security level, which communicates 1032 bits for the $\aux$
and $\msgs$ when LowMC uses a full S-box layer, and 1200 bits when LowMC
uses a partial S-box layer~\cite{TCHES:KalZav20}. 

\subsubsection{Signature Scheme Details}
The signature scheme is given in \cref{fig:23-picnic}.
\paragraph{Random notes} \greg{These should be worked into the text as appropriate}
\begin{itemize}
\item OWF vs. PRF: for the OWF I don't think there is any performance advantage to
using compressed matrices (circulant matrices). So better to use
fully random ones. 

\item The parameters above need review.  I'm pretty sure $(128, 400, 81)$ is supported
by the analysis in Itai's document but the others may not be. 

\item Key generation: Choose random $x$ as a secret key, and a seed $s_A$ such that
$s_A$ expands to a matrix $A$ that is full rank.  We use a unique $A$ per
signer in order to avoid multi-target attacks against $F$. Compute $y = F(x)$
and set $(y, s_A)$ as the public key.  \greg{We could generate the public matrix $G$ 
from $s_A$ as well, or we could fix it once for all signers. Is there a security reason to go one with random $G$?}

\item The rest of this section briefly recalls KKW, explains that we choose
parameters ($(M, N, \tau)$ the number of MPC instances $M$, the number of
parties $N$, and the number of online instances $\tau$) in the same way as
Picncic, shows the signature size formula (given $(M, N, \tau)$) and gives some
concrete example siganture sizes at the L1 level. 

\item Optionally we may compare the NIST L5 level (AES-256 equivalent, i.e., 256-bit
classical, 128-bit quantum secure), in case the security of the (2,3)-OWF
scales better than LowMC. 
\end{itemize}


Given the MPC protocol above, We can compute the values $\hat{x}$, $\aux$ and $\msgs$ for the (2,3)-OWF 
and neatly drop it into the KKW proof system of Picnic. 


\begin{figure}[p]
% \begin{adjustbox}{center,raise={8ex}{\height}} % for LNCS
%	\begin{adjustbox}{max width=\textwidth,center}
 \begin{minipage}[t]{1.1\textwidth}
 \begin{protocolbox}{(2,3)-OWF Signatures}
 \begin{description}
    \item[Inputs] Both signer and verifier have $y = F(x)$, the
        message to be signed $\Msg$, and the signer has the secret key $x$.  The
            parmeters of the protocol $(M, N, \tau)$ are described in the text.
    \item[Commit] For each MPC instance $k\in[M]$, the signer does the following.
    \begin{enumerate}
        \item Choose uniform $\seed^{(k)}$ and use  to generate values $(\seed^{(k)}_i)_{i \in [N]}$, and compute  
        $\aux^{(k)}$ as described in the text. 
        For $i=1,\ldots N-1$, let $\state^{(k)}_i = \seed^{(k)}_i$ and  let $\state^{(k)}_{N} = \seed^{(k)}_{N} || \aux^{(k)}$.
        \item Commit to the preprocessing phase:
        \begin{align*}
        \com^{(k)}_{i} = \hash(\state^{(k)}_i) \text{ for all } i\in [N], \quad 
        h^{(k)} = \hash(\com^{(k)}_{1},\ldots,\com^{(k)}_{N}).
        \end{align*}						
        \item Compute MPC input $\hat{x}^{(k)} = x + x'^{(k)}$ based on the secret key $x$ and the random values $x'^(k)$ defined by preprocessing.
        \item Simulate the online phase of the MPC protocol, producing $(\msgs^{(k)}_i)_{i \in [N]}$.			
        \item Commit to the online phase:
        $
         h'^{(k)}= \hash(\hat{x}^{(k)}, \msgs_{1}^{(k)}, \ldots, \msgs_{N}^{(k)} ).
        $
    \end{enumerate}
    
    \item[Challenge] 
    The signer computes $\ch = \hash(h_1, \ldots h_M, h_1', \ldots, h_M',
    \Msg)$, then expands $\ch$ to the challenge $(\CCC, \PPP) := \Expand(\ch)$,
    where $\CCC$ is a $\tau$-sized subset of $[M]$ and $\PPP = (p_k)_{k \in
    \CCC}$ is a list of length $\tau$.  The function $\Expand$ is based on $\hash$, is deterministic and
    outputs uniformly random values. 
    For each MPC instance in $k\in\CCC$, $p_k$ represents the index of the party that remains unopened. 
    
    \item[Signature output]
%The signer outputs $\ch$, and the following values.
%    For each $k \in [M]\setminus \CCC$, the signer outputs $\seed^{(k)}$ and $h^{(k)}$.
%    For each $k \in \CCC$, the signer outputs 
%        $\com^{(k)}_{p_k}$, $(\state^{(k)}_{i})_{i \neq p_k}$, 
%        $\hat{x}^{(k)}$ and $\msgs_{p_k}^{(k)}$.
The signature $\sigma$ on $\Msg$ is 
\[
\sigma = (\ch, 
          ((\seed^{(k)}, h^{(k)} )_{k\not\in\CCC}, 
          ( \com^{(k)}_{p_k}, (\state^{(k)}_{i})_{i\neq p_k}, \hat{x}^{(k)}, \msgs_{p_k}^{(k)} )_{k\in\CCC})_{k\in[M]})
\]
    
    \item[Verification] The verifier parses $\sigma$ as above, and does the following.  
    \begin{enumerate}
        \item Check the preprocessing phase. For each $k\in[M]$:
        \begin{enumerate}
        \item If $k \in \CCC$: for all $i\in[N]$  such that $i \neq p_k$, the verifier uses $\state^{(k)}_{i}$ to compute $\com^{(k)}_{i}$ as 
            the signer did, then computes $h'^{(k)} = \hash(\com^{(k)}_{1},\ldots,\com^{(k)}_{N})$ using 
            the value $\com^{(k)}_{p_k}$ from $\sigma$. 
        \item If $k\not\in\CCC$: the verifier uses $\seed^{(k)}$ to compute $h'^{(k)}$ as the signer did.
%        \item Finally, the verifier computes $h_\off = \hash(h'^{(1)}, \ldots, h'^{(M)})$
        \end{enumerate} 
        
        \item Check the online phase:
        \begin{enumerate}
            \item For each $k \in \CCC$ the verifier simulates the online phase using $(\state^{(k)}_{i})_{i \neq p_k}$,  
                masked witness $\hat{x}$ and $\msgs^{(k)}_{p_k}$ to compute $(\msgs_i)_{i \neq p_k}$. 
                Then compute $h^{(k)}$ as the signer did. The verifier outputs `invalid' if the output of the MPC simulation is not equal to $y$.
%            \item The verifier computes $h_\on = \hash(h^{(1)}, \ldots, h^{(M)})$ using the received $h^{(k)}$ for $k \in [M] \setminus \CCC$. 
        \end{enumerate}
    \item The verifier computes $\ch' = \hash(h_1, \ldots h_M, h_1', \ldots, h_M', \Msg)$ and outputs `valid' if $\ch' = \ch$ and `invalid' otherwise. 
    \end{enumerate}
 \end{description}
 \end{protocolbox}
 \end{minipage}
% \end{adjustbox}
	\vspace*{-10pt}
	\caption{\label{fig:23-picnic}Picnic-like signature scheme using the (2,3)-OWF and the KKW proof sytem.} 
\end{figure}


\subsection{Distributed Picnic}
\greg{Still no good ideas on how to do this}
