%!TEX root = ../main.tex
\newpage
\section{Distributed Protocols}
\noindent \mahimna{Still need to write the surrounding text}

\noindent We now describe our efficient distributed protocols to compute our candidate wPRF construction (Construction~\ref{construction:23-central-wprf}) in several settings.


\subsection{Technical Overview}

\paragraph{Notation.}
Recall that our PRF construction is parameterized by $n, m$ and $t$, where $n$ is the length of the input vector, $m$ is the length of the intermediate vector, and $t$ is the length of the output vector. We use $\mat{K} \in \Z_2^{m \times n}$ and $x \in \Z_2^n$ to denote the PRF key and input respectively. Our PRF keys are block-circulant and therefore, we can use a single vector $k \in \Z_2^n$ to represent $\mat{K}$. We use $w = \mat{K}x \in \Z_2^{m}$ to represent the intermediate vector and $z \in \Z_3^m$ to represent its cast to a vector over $\Z_3$. Finally, we use $\mat{G} \in \Z_3^{t \times m}$ to represent the public mod-3 linear mapping and $y = \mat{G}z \in \Z_3^t$ to represent the output vector.

For a variable $v$, we use $r_v$ to denote a random mask vector in the same domain, and denote their sum by $v'$. For instance, instead of revealing the input $x$, it will often be masked by a random vector $r_x$, with the resulting sum $x' = x \oplus r_x$ being revealed.

\paragraph{Conversion from Mod-2 to Mod-3.}
A key component of our distributed protocols involves casting the $\Z_2$ vector $w$ to its equivalent $\Z_3$ vector $z$. For this, we will often start by having a masked version $w' = w \oplus r_w$ publicly known to all parties. We now describe a useful functionality $\unmask$ that will enable parties to obtain a mod-3 additive sharing of $z$ given $w' = w \oplus r_w$ publicly, and a mod-3 additive sharing of $p = r_w$ (viewed as a vector in $\Z_3^m$). We describe the needed functionality in Functionality~\ref{functionality:mod23-convert}, and provide a local protocol (Protocol~\ref{prot:mod23-convert}) that computes it.

\begin{functionality}[Unmask functionality $\unmask$]
~
\begin{itemize}
    % \item \textbf{Inputs}: The parties $\party_1$ to $\party_N$ get $w' = w \xor r_w \in \Z_2^m$ as common input and hold shares of $p = r_w$ viewed as a vector in $\Z_3^m$. Concretely, let $w, r_w \in \Z_2^m$ and $p_1, \dots, p_N \in \Z_3^m$ such that $\bigboxplus_{i=1}^N p_i = r_w$ (viewed over $\Z_3$) and let $w' = w \xor r_w$. Then, each $\partyi$ holds $w'$ and $p_i$.

    \item \textbf{Inputs}: The parties $\party_1$ to $\party_N$ get $w' = w \xor r_w \in \Z_2^m$ as common input and hold shares of $p = r_w$ viewed as a vector in $\Z_3^m$. Concretely, let $w, r_w \in \Z_2^m$ and $p^{(1)}, \dots, p^{(N)} \in \Z_3^m$ such that $\bigboxplus_{i=1}^N p^{(i)} = r_w$ (viewed over $\Z_3$) and let $w' = w \xor r_w$. Then, each $\partyi$ holds $w'$ and $p^{(i)}$.


    \item \textbf{Output}: Each party $\partyi$ outputs a $z^{(i)} \in \Z_3^m$, such that $z = \bigboxplus_{i=1}^N z^{(i)} = w$.
\end{itemize}
\label{functionality:mod23-convert}
\end{functionality}


\begin{protocol}[Local protocol $\protunmask$ for $\unmask$]
~
\begin{itemize}
    \item Party $\partyi$ is given $w' \in \Z_2^m, p^{(i)} \in \Z_3^m$ as input. Let $w' = (w'_1, \dots, w'_m)$ where each $w'_j \in \Z_2$ and $p^{(i)} = (p^{(i)}_1, \dots, p^{(i)}_m)$ where each $p^{(i)}_j \in \Z_3$. Now, for each $j \in [m]$, $\partyi$ computes
    \[
        v^{(i)}_j = p^{(i)}_j \boxplus w'_j \cdot p^{(i)}_j
    \]
    \item For $i \neq 1$, $\partyi$ outputs $z^{(i)} = v^{(i)} = (v^{(i)}_1, \dots, v^{(i)}_m)$.
    \item $\party_1$ first computes $z^{(1)}_j = v^{(i)}_j \boxplus w'_j$ for each $j \in [m]$ and then outputs $z^{(1)} = (z^{(1)}_1, \dots, z^{(1)}_m)$
\end{itemize}
Notice that there is no communication required and that the protocol can be computed locally by all parties.
\label{prot:mod23-convert}
\end{protocol}

\begin{lemma}
$\protunmask$(Protocol~\ref{prot:mod23-convert}) correctly computes $\unmask$ (Functionality~\ref{functionality:mod23-convert}). 
\end{lemma}
\begin{proof}
Let $r_w = (r_{(w,1)}, \dots, r_{(w,m)})$, $z = (z_1, \dots, z_m)$, and for each party $\party_i$, let $z^{(i)} = (z^{(i)}_1, \dots, z^{(i)}_m)$. Now, notice that, for each $j \in [m]$,
\begin{itemize}
    \item If $w'_j = 0$, then $r_{(w,j)} = w_j$. Therefore,
    \[
     z_j = \bigboxplus_{i=1}^N z^{(i)}_j = \bigboxplus_{i=1}^N p^{(i)}_j = r_{(w,j)} = w_j.
    \]
    \item If $w'_j = 1$, then $w_j = 1 - r_{(w,j)}$. Therefore,
    \[
    z_j = \bigboxplus_{i=1}^N z^{(i)}_j = w'_j \boxplus \left(2\bigboxplus_{i=1}^N p^{(i)}_j \right) = 1 \boxplus (2 \cdot r_{(w,j)}).
    \]
    \noindent Now, when $r_{(w,j)} = 0$, we have $z_j = 1 = 1 - r_{(w,j)} = w_j$, and when $r_{(w,j)} = 1$, we have $z_j = 0 = 1 - r_{(w,j)} = w_j$.
\end{itemize}
Consequently, we have $z_j = w_j$ for all $j \in [m]$, i.e., $z = w$, which completes the proof.
\end{proof}

\subsection{2-party Distributed Evaluation in the Preprocessing Model}

\subsection{3-party Distributed Evaluation}

\subsection{Fully Distributed $n$-party Evaluation in the Preprocessing Model}

\subsection{2-party Public Input Evaluation}

\subsection{Oblivious PRF Evaluation}
