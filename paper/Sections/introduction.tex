%!TEX root = ../main.tex

\section{Introduction}
\label{sec:introduction}

\greg{Does anyone know why the PDF doesn't have the index on the left hand side with links to all of the sections?}


\medskip

%-------------------------------------------%
Symmetric-key primitives like one-way functions (OWFs)~\cite{?},
% Not sure about citation for OWF, but can cite Levin's survey: https://arxiv.org/abs/cs/0012023 
 pseudorandom generators (PRGs)~\cite{blum1984-prg,yao1982-prg}, 
and pseudo-random functions (PRFs)~\cite{goldreich1984-prf} are deployed in innumerable settings, and serve as fundamental building blocks of modern cryptography. While traditional use cases primarily considered settings where the function evaluation was done by a single party, many applications (recently also arising in the context of cryptocurrencies \mahimna{cite more here}) require evaluation in a distributed fashion to avoid single points of failure. This motivates the study of secure multiparty computation (MPC) protocols for evaluating such symmetric-key primitives in a setting where inputs, outputs, and keys are secret-shared or distributed between two or more parties.

Towards this goal, a long line of work~\cite{damgard2010-aes, pinkas2009-aes, wang2017-mpc} has made substantial progress on concretely efficient MPC protocols for distributing the computation of symmetric primitives, such as AES or SHA-256, which are widely used in practice. Unfortunately, the constructions themselves were not designed with distributed evaluation in mind, and are often clunky to optimize for. More recent work~\cite{albrecht2015-lowmc, grassi2016-mpcfriendly, boneh2018-darkmatter} has therefore proposed to start from scratch by designing \textit{MPC-friendly} primitives from the ground up. 
%So far, the primary focus has been on MPC-friendly PRFs. 

In this work, we continue this line of research by proposing a new suite of \textit{simple} MPC-friendly candidate designs for a number of symmetric primitives: (weak)\footnote{A weak PRF is one whose security only holds when evaluated on {\em random} inputs. In many applications of strong PRF, a weak PRF can be used instead by first applying a hash function (modeled as a random oracle) to the input~\cite{someweakPRFref}.
} PRFs, OWFs, and PRGs.


\paragraph{The MPC setting.} We focus on the {\em semi-honest} setting of security for simplicity. While recent general techniques from the literature~\cite{BBCGI19,BGIN19} can be used to extend some of our protocols to the malicious security model with a low amortized cost, we leave such an extension to future work. We consider protocols for both two parties (2PC) and multiple parties, both with and without an honest majority assumption, and both with and without preprocessing. For concreteness, in the following we consider by default the standard setting of (semi-honest) 2PC with preprocessing. However, most of our contribution applies to the other models as well. 

\paragraph{Efficiency metrics for MPC.}   Concretely efficient MPC protocols can be divided into two broad categories: protocols based on {\em garbled circuits}~\cite{Yao} and protocols based on {\em linear secret sharing}~\cite{GMW,BGW,CCD}. Protocols based on garbled circuits have low round complexity but their communication cost will be prohibitively high for our purposes. We will therefore focus on protocols based on secret sharing. Roughly speaking, the complexity of evaluating  a given function $f$ using such protocols is determined by the {\em size} and the {\em depth} of a {\em circuit} $C$ that evaluates $f$.  Here we assume that $C$ is comprised of atomic gates of two kinds: {\em linear gates} (computing modular addition or multiplication by a public value) and MPC-friendly {\em nonlinear gates}  that are supported by efficient subprotocols. A typical example for a nonlinear gate is modular multiplication of two secret values. Given such a representation for $f$, the {\em communication} cost of an MPC protocol for $f$ scale linearly with the {\em size} of $C$, namely the number of gates weighted by the ``MPC cost'' of each gate, whereas the {\em round complexity} scales linearly with the {\em depth} of $C$, namely the of gates on a longest input-output path. Since linear gates do not require any interaction, they do not count towards the size or the depth. We use the term ``nonlinear size'' and ``nonlinear depth'' to refer to the size and the depth when excluding linear gates. 

\paragraph{Our design criteria.}  The above efficiency metrics for MPC are quite crude, since not all kinds of nonlinear gates are the same. However, they still serve as a good intuitive guideline for the design of MPC-friendly primitives. More concretely, we would like to design primitives with the following goals in mind.

\begin{itemize}[itemsep=1ex]
    \item \textit{Low nonlinear depth}. Minimizing round complexity calls for minimizing nonlinear depth. Unfortunately, constructions like AES or even MPC-friendly ones such as LowMC have quite a high nonlinear depth, which leads to high-latency protocols when using the secret sharing approach.
    
\item \textit{Small nonlinear size}.
 For keeping the communication complexity low, we would like to minimize the number of nonlinear gates and make them as ``small'' and ``MPC-friendly'' as possible. 

\item \textit{High algebraic degree}.
Security of block ciphers and (weak) PRFs provably requires high algebraic degree. While there are low-degree implementations of weaker primitives such as OWF and PRG~\cite{MQref,Goldreich,AIK05}, these typically come at the price of bigger input and output size and high nonlinear size~\cite{AsiacryptCouteau}.
    
    \item \textit{Simplicity}.  A simple design is almost always easier to implement and prone to fewer errors and attacks. This is particularly valuable since a substantial amount of work~\cite{?} has previously gone into implementations that resist timing and cache side-channels. Simpler constructions are also easier to reason about and cryptanalyze, which builds confidence in their security, and may draw enough interest to be analyzed outside the cryptography community.
\end{itemize}

\iffalse     
    Recent techniques for securely generating many instances of ``OT'' and ``VOLE'' correlations  with low communication and computation costs~\cite{BCGI18,BCGKIS19,more} motivate primitives that can benefit from these
    
    and can be generated in the \textit{offline} phase. This randomness is usually assumed to be given to the protocol parties by a trusted dealer. Several MPC protocols~\cite{?} have used a varying types correlated randomness to increase efficiency in the input-dependent \textit{online} phase.

    \hspace*{1em} Our final goal is to design candidates that take advantage of two special types of correlations: Obvious transfer (OT) correlations, and (vector) oblivious linear evaluation (OLE/VOLE) correlations. A major selling point for these correlations over other types is their ease of generation even without a trusted dealer. Recent work~\cite{?} for instance, has shown how pseudorandom correlation generators (PCGs) can be used to generate millions of OT and VOLE correlations with little to no communication. Furthermore, it is not necessary to store all of these correlations; they can stored in a compressed form, and expanded only when needed~\cite{?}.


    \hspace*{1em} In this paper, we strive to find the best of both worlds. The first design goal for our constructions therefore, is to achieve high nonlinearity for the overall computation while maintaining a low nonlinear \textit{depth}. Intuitively, this will enable us to achieve low round complexity (using a secret-sharing based approach) without the communication overhead of garbled circuits.

    \hspace*{1em} This means that although our protocols are in the preprocessing model, the correlations we require can be efficiently generated and compressed without a trusted dealer. Furthermore, since we also aim for small nonlinear sized constructions, the upshot of our design is that distributed protocols will be efficient even in an online-only setting. 
\fi

\paragraph{\bf The alternating moduli paradigm.} The above design criteria seem inherently at odds with each other. How can ``high algebraic degree'' co-exist with ``small gates'' and ``low nonlinear depth''? A new design paradigm that may help simultaneously achieve our three goals was recently proposed by Boneh et al.~\cite{boneh2018-darkmatter} and further analyzed by Cheon et al.~\cite{adventures}. The idea is to break the computation into two or more parts, where each part includes a linear function over a {\em different modulus}. The simplest choice of moduli is 2 and 3. 

The main weak PRF candidate from~\cite{boneh2018-darkmatter} has the following simple description: the input $x$ is a vector over  $\Z_2$ and the secret key specifies a matrix $K$ over  $\Z_2$. The PRF first computes the matrix-vector product $Kx$ over  $\Z_2$, then interprets the result as a vector over $\Z_3$ in the natural way,  and finally applies a public, compressive linear mapping over $\Z_3$ to obtain an output vector $y$ over $\Z_3$. 

The above mapping from $x$ and $K$ to $y$ has two nonlinear steps: The first is the matrix-vector product over $\Z_2$, whose cost an be reduced when the matrix $K$ has a special form. The second is a {\em conversion} of a mod-2 vector to a mod-3 vector, which consists of small parallel (finite-size) nonlinear gates.  Overall, the nonlinear depth is 2. Why is this a high-degree function? Viewing both the input and the (binary representation of) the output as vectors over $\Z_2$, high degree over $\Z_2$ comes from the final linear mapping over $\Z_3$. Viewing the input as a vector over $\Z_3$, high degree comes from the linear mapping over $\Z_2$ defined by the key.  Despite its simplicity, the design can be conjectured to have a good level of security with small input and key size (say, 256 bits for 128-bit security). It mostly resisted the initial cryptanalysis, where attacks found in~\cite{adventures} require a very high sample complexity and are quite easy to circumvent by slightly modifying the design.   

\iffalse
The main technique by which we achieve all three of our design goals is to consider alternating linear functions over different (prime) moduli. The only nonlinear part of the constructions will now be to switch between the different moduli, which leads to a very small round complexity. Furthermore, Boneh et al.~\cite{boneh2018-darkmatter} showed that linear functions over one moduli cannot be well approximated by low degree polynomials over a different moduli. Consequently, even a simple design that alternates between different moduli can result in a highly non-linear overall computation. In other words, this approach provides high algebraic degree with low nonlinear depth. 

As the simplest possible instance of this approach, we consider alternating linear functions over $\Z_2$ and $\Z_3$. Boneh et al. found that linear functions over $\Z_2$ are highly nonlinear over $\Z_3$ while linear functions over $\Z_3$ are highly nonlinear over $\Z_2$. Furthermore, using small moduli allows for efficient designs for ``switching'' between the moduli. In fact, we show how conversions between the moduli are “small” nonlinear gates and can be implemented efficiently from OT and VOLE correlations.
\fi

A primary motivation for the above design was its MPC-friendliness. Indeed, several MPC protocols were proposed in~\cite{boneh2018-darkmatter} for its distributed evaluation. These protocols were shown to have significant advantages over earlier MPC-friendly designs, but this was argued either for the honest-majority 3-party case or for 2PC in the preprocessing model. Another, very different, motivation is the goal of identifying simple function classes that are ``hard to learn.''  Indeed,  the conjectures from~\cite{boneh2018-darkmatter} imply hardness of learning results for low complexity classes such as (depth-2) $\mathsf{ACC}^0$ or sparse $\Z_3$ polynomials. These conjectures may have interesting implications outside the field of cryptography~\cite{complexity-theory-works}.

The initial work of~\cite{boneh2018-darkmatter,adventures} have only scratched the surface of the kind of questions one may ask. Why focus on PRFs and not on simpler primitives such as OWFs and PRGs? Distributed evaluation of these primitives is motivated by many applications. 

leave much to be desired. First, they all focus 


% All the candidates we propose are based on similar interplays between linear mappings in $\Z_2$ and $\Z_3$.
%\mahimna{write something about complexity theory implications}

\subsection{Our Contribution}




In this section, we provide a detailed overview of the main contributions of this paper.


\paragraph{\bf \textnormal{OT} and \textnormal{VOLE} friendliness}.
    MPC protocols in the preprocessing modelcan take advantage of input-independent correlated randomness to better handle nonlinear gates~\cite{Beaver,BDOZ,SPDZ,PowerOfCorrelatedRandomness,TinyTables,BGI19}. However, some kinds of correlated randomness are better than other. Recent work~\cite{?} for instance, has shown how pseudorandom correlation generators (PCGs) can be used to generate millions of ``OT'' and ``VOLE'' correlations with very low and computation costs. Furthermore, it is not necessary to store all of these correlations; they can stored in a compressed form, and expanded only when needed~\cite{?}. Roughly speaking, an OT correlation is useful for evaluating a ``simple'' nonlinear gates (such as Boolean AND) and a VOLE correlation is useful for scalar-vector products. We would like to maximize the potential benefit from these recent techniques.


\mahimna{still writing}



\subsubsection{New candidate constructions.}
We introduce several candidate constructions for the (weak)PRF, OWF, and PRG primitives. Our candidates are all based on similar interplays between alternating modulo 2 and modulo 3 linear mappings.

\begin{itemize}
    \item \textbf{Candidate Weak PRFs.}
    We start with the weak PRF candidate proposed in~\cite{boneh2018-darkmatter}

    Let $\mat{K}$ be a secret key matrix in $\Z_2^{m \times n}$. For an input $x$, the $(2,3)$-wPRF candidate is defined as $\mathsf{F}_\mat{K}(x) = \mat{B}(\mat{K}x)$ where $\mat{B} \in \Z_3^{t \times m}$ is a public matrix and $w = \mat{K}x$ is first reinterpreted as a 0/1 vector over $\Z_3$.


    \item \textbf{Candidate OWFs}

    \item \textbf{Candidate PRGs.}

\end{itemize}

\subsubsection{Cryptanalysis and implications on parameter choices.}
Given that the constructions heavily mix linear operations over $\Z_2$ and $\Z_3$, 
we will rely on the arguments of Boneh et al.~\cite{boneh2018-darkmatter}, 
and conjecture that algebraic attacks do not threaten their security.
Instead, we will focus of combinatorial attacks and statistical tests.

Our most interesting attack on the 
candidate OWF reduces the inversion problem to a particular type of subset-sum problem,
where addition simultaneously involves operations over $\Z_2$ and $\Z_3$.
Thus, we can invert the OWF by applying a variant of recent advanced algorithms
for solving subset-sum that are based on the 
\emph{representation technique}~\cite{Howgrave-GrahamJ10,BeckerCJ11,BonnetainBSS20}.
Compared to a standard meet-in-the-middle approach, 
this attack forced us to increase the parameters by about $30\%$.

For the candidate weak PRF and PRG constructions, 
the security analysis is mainly focused on
statistical distinguishers that exploit a bias in the output.
The strength of such a bias depends on the minimal distance of the 
code generated by the second linear operation of the construction.
As this code is generated at random, we use the probabilistic method
(in a similar way it is used to obtain the Gilbert–Varshamov bound for linear codes) 
to argue that its minimal distance is sufficiently large, except with negligible probability. 


\subsubsection{Distributed protocols and optimized implementations}
 
\paragraph{Efficient modulus conversion gates.}
Since our constructions use shares over both $\Z_2$ and $\Z_3$, it is necessary to be able to switch between the two. We provide the following protocols to do this efficiently. 

\begin{itemize}
    \item \textbf{$\Z_2 \to \Z_3$ conversion.} Consider $x \in \Z_2^l$. Given a sharing $\share{x}$ over $\Z_2$, the goal is to convert to a sharing of the same $x$ but over $\Z_3$. For this, the dealer provides the parties with a shares of a random bit-vector $\tilde{x} \in \Z_2^l$ over $\Z_2$, and shares of the same vector $r = \tilde{x}$, but over $\Z_3$. The conversion protocol now works as follows. First the parties locally add their shares to get $\share{\hat{x}} = \share{x} + \share{\tilde{x}} \bmod 2$. The parties then reconstruct $\hat{x}$ by exchanging their shares. Now, a $\Z_3$ sharing of $x^* \in \Z_3^l; x^* = x$ can be computed as:

    \[
        \share{x^*} = \share{\hat{x}} + \share{r} + (\hat{x} \odot \share{r}) \bmod 3
    \]
    where $\odot$ denotes the Hammard (element-wise) product modulo 3.

    \item \textbf{$\Z_3 \to \Z_2$ conversion.}
    Consider $x \in \Z_3^l$. Given a sharing $\share{x}$ over $\Z_3$, the goal is to convert to a sharing over $\Z_2$ of $x^* = x \bmod 2$. For this, the dealer provide the parties with the following correlated randomness. First it samples a random $\Z_3$ vector $\tilde{x}$ as a mask for $x$. It then computes $u = \tilde{x} \bmod 2$ and $v = (\tilde{x} + \textbf{1}^l \bmod 3) \bmod 2$ where $\textbf{1}^l$ is the all-ones vector of length $l$. Finally, the dealer provides the sharings $\share{x}$ (over $\Z_3$), $\share{u}$ (over $\Z_2$) and $\share{v}$ (over $\Z_2$) to the parties.

    \hspace*{1em} Now, the conversion protocol works as follows: First, the parties compute the sharing $\share{\hat{x}} = \share{x} + \share{\tilde{x}}$, and then exchange their shares to reconstruct $\share{\hat{x}}$.

\end{itemize}


\subsubsection{Applications.}


\newpage
