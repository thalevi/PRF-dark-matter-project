%!TEX root = ../main.tex

\section{Introduction}
\label{sec:introduction}

\greg{Does anyone know why the PDF doesn't have the index on the left hand side with links to all of the sections?}

\greg{To me, one of the nice things about these primitives is how elegant and
simple they are.  (e.g., I showed the (2,3)-OWF to a colleague and his reaction
was, wow this is so simple, just two matrix multiplies, can it really be a
OWF?) Esp.  when we compare the (2,3)-OWF to a (MPC-friendly) block cipher. But
the simplicity doesn't really come across in the description of Section 3,
maybe the introduction is a good place to make the point (and give a
description of the (2,3)-OWF as an example).  }

\medskip

%-------------------------------------------%
Symmetric-key primitives like one-way functions (OWFs)~\cite{?},
% Not sure about citation for OWF, but can cite Levin's survey: https://arxiv.org/abs/cs/0012023 
 pseudorandom generators (PRGs)~\cite{blum1984-prg,yao1982-prg}, 
and pseudo-random functions (PRFs)~\cite{goldreich1984-prf} are deployed in innumerable settings, and serve as fundamental building blocks of modern cryptography. While traditional use cases primarily considered settings where the function evaluation was done by a single party, many applications (recently also arising in the context of cryptocurrencies \mahimna{cite more here}) require evaluation in a distributed fashion to avoid single points of failure. This motivates the study of secure multiparty computation (MPC) protocols for evaluating such symmetric-key primitives in a setting where inputs, outputs, and keys are secret-shared or distributed between two or more parties.

Towards this goal, a long line of work~\cite{damgard2010-aes, pinkas2009-aes, wang2017-mpc} has made substantial progress on concretely efficient MPC protocols for distributing the computation of symmetric primitives, such as AES or SHA-256, which are widely used in practice. Unfortunately, the constructions themselves were not designed with distributed evaluation in mind, and are often clunky to optimize for. More recent work~\cite{albrecht2015-lowmc, grassi2016-mpcfriendly, boneh2018-darkmatter} has therefore proposed to start from scratch by designing \textit{MPC-friendly} primitives from the ground up. 
%So far, the primary focus has been on MPC-friendly PRFs. 

In this work, we continue this line of research by proposing a new suite of \textit{simple} MPC-friendly candidate designs for a number of symmetric primitives: (weak)\footnote{A weak PRF is one whose security only holds when evaluated on {\em random} inputs. In many applications of strong PRF, a weak PRF can be used instead by first applying a hash function (modeled as a random oracle) to the input~\cite{someweakPRFref}.
} PRFs, OWFs, and PRGs. We focus on the {\em semi-honest} setting of security for simplicity. While recent general techniques from the literature~\cite{BBCGI19,BGIN19} can be used to extend some of our protocols to the malicious security model with a low amortized cost, we leave such an extension to future work. 

\paragraph{Efficiency metrics for MPC.}   Concretely efficient MPC protocols can be divided into two broad categories: protocols based on {\em garbled circuits}~\cite{Yao} and protocols based on {\em secret sharing}~\cite{GMW,BGW,CCD}. Protocols based on garbled circuits have low round complexity but their communication cost will be prohibitively high for our purposes. We will therefore focus on protocols based on secret sharing. Roughly speaking, the complexity of evaluating  a given function $f$ using such protocols is determined by the {\em size} and the {\em depth} of a {\em circuit} $C$ representation of $f$.  Here we assume that $C$ is comprised of atomic gates of two kinds: {\em linear gates} (computing modular addition or multiplication by a public value) and MPC-friendly {\em nonlinear gates}  that are supported by efficient subprotocols. A typical example for a nonlinear gate is modular multiplication of two secret values. Given such a representation for $f$, the {\em communication} cost of an MPC protocol for $f$ scale linearly with the {\em size} of $C$, whereas the {\em round complexity} scales linearly with the {\em depth}. Since linear gates do not require any interaction, they do not count towards the size or the depth. We use the terms ``nonlinear size'' and ``nonlinear depth'' to refer to the size and depth excluding linear gates. In particular, 

if a function is composed of ``MPC-friendly'' atomic gates that consists of linear gates (performing, say, modular addition) and nonlinear gates (performing multiplication or another nonlinear operation that can 

We consider protocols for both two parties (2PC) and multiple parties, both with and without an honest majority assumption, and both with and without preprocessing. For concreteness, consider by default the standard setting of (semi-honest) 2PC with preprocessing, though most of the following discussion applies to all other settings as well. 

The efficienty are designed with the following goals in mind:

\begin{itemize}[itemsep=1ex]
    \item \textit{High nonlinearity but low nonlinear depth}.
Garbled circuit based protocols usually have better round complexity (independent of circuit depth) while secret-sharing based protocols have much smaller communication complexity (especially in the preprocessing model). The round complexity of the latter scales with \textit{nonlinear depth} since linear functions can be computing non-interactively given a linear secret-sharing scheme. Unfortunately, constructions like AES or even MPC-friendly ones such as LowMC have a high nonlinear depth, which forms a latency bottleneck in their distributed evaluation.

    \hspace*{1em} In this paper, we strive to find the best of both worlds. The first design goal for our constructions therefore, is to achieve high nonlinearity for the overall computation while maintaining a low nonlinear \textit{depth}. Intuitively, this will enable us to achieve low round complexity (using a secret-sharing based approach) without the communication overhead of garbled circuits.

    \item \textit{Small nonlinear size}.
    While our first design goal focused on reducing the number of (sequential) nonlinear gates, we would also like to reduce the communication complexity for evaluating the nonlinear gates. Our second design goal therefore, is to incorporate ``simple'' nonlinear gates that can be evaluated with low communication overhead. 

    \hspace*{1em} Simplicity also has several independently valuable consequences. A simple design is almost always easier to implement and prone to fewer errors and attacks. This is particularly valuable since a substantial amount of work~\cite{?} has previously gone into implementations that resist timing and cache side-channels. Simpler constructions are also easier to reason about and cryptanalyze which builds confidence in their security.

    \item \textit{\textnormal{OT} and \textnormal{VOLE} friendliness}.
    MPC protocols in the preprocessing model can take advantage of structured randomness that is independent of the protocol inputs and can be generated in the \textit{offline} phase. This randomness is usually assumed to be given to the protocol parties by a trusted dealer. Several MPC protocols~\cite{?} have used a varying types correlated randomness to increase efficiency in the input-dependent \textit{online} phase.

    \hspace*{1em} Our final goal is to design candidates that take advantage of two special types of correlations: Obvious transfer (OT) correlations, and (vector) oblivious linear evaluation (OLE/VOLE) correlations. A major selling point for these correlations over other types is their ease of generation even without a trusted dealer. Recent work~\cite{?} for instance, has shown how pseudorandom correlation generators (PCGs) can be used to generate millions of OT and VOLE correlations with little to no communication. Furthermore, it is not necessary to store all of these correlations; they can stored in a compressed form, and expanded only when needed~\cite{?}.

    \hspace*{1em} This means that although our protocols are in the preprocessing model, the correlations we require can be efficiently generated and compressed without a trusted dealer. Furthermore, since we also aim for small nonlinear sized constructions, the upshot of our design is that distributed protocols will be efficient even in an online-only setting. 
\end{itemize}

The main technique by which we achieve all three of our design goals is to consider alternating linear functions over different (prime) moduli. The only nonlinear part of the constructions will now be to switch between the different moduli, which leads to a very small round complexity. Furthermore, Boneh et al.~\cite{boneh2018-darkmatter} showed that linear functions over one moduli cannot be well approximated by low degree polynomials over a different moduli. Consequently, even a simple design that alternates between different moduli can result in a highly non-linear overall computation. In other words, this approach provides high algebraic degree with low nonlinear depth. 

As the simplest possible instance of this approach, we consider alternating linear functions over $\Z_2$ and $\Z_3$. Boneh et al. found that linear functions over $\Z_2$ are highly nonlinear over $\Z_3$ while linear functions over $\Z_3$ are highly nonlinear over $\Z_2$. Furthermore, using small moduli allows for efficient designs for ``switching'' between the moduli. In fact, we show how conversions between the moduli are “small” nonlinear gates and can be implemented efficiently from OT and VOLE correlations.

% All the candidates we propose are based on similar interplays between linear mappings in $\Z_2$ and $\Z_3$.
\mahimna{write something about complexity theory implications}

\subsection{Our contributions}
In this section, we provide a detailed overview of the main contributions of this paper.
\mahimna{still writing}

\subsubsection{New candidate constructions.}
We introduce several candidate constructions for the (weak)PRF, OWF, and PRG primitives. Our candidates are all based on similar interplays between alternating modulo 2 and modulo 3 linear mappings.

\begin{itemize}
    \item \textbf{Candidate Weak PRFs.}
    We start with the weak PRF candidate proposed in~\cite{boneh2018-darkmatter}

    Let $\mat{K}$ be a secret key matrix in $\Z_2^{m \times n}$. For an input $x$, the $(2,3)$-wPRF candidate is defined as $\mathsf{F}_\mat{K}(x) = \mat{B}(\mat{K}x)$ where $\mat{B} \in \Z_3^{t \times m}$ is a public matrix and $w = \mat{K}x$ is first reinterpreted as a 0/1 vector over $\Z_3$.


    \item \textbf{Candidate OWFs}

    \item \textbf{Candidate PRGs.}

\end{itemize}

\subsubsection{Cryptanalysis and implications on parameter choices.}


\subsubsection{Distributed protocols and optimized implementations}
 
\paragraph{Efficient modulus conversion gates.}
Since our constructions use shares over both $\Z_2$ and $\Z_3$, it is necessary to be able to switch between the two. We provide the following protocols to do this efficiently. 

\begin{itemize}
    \item \textbf{$\Z_2 \to \Z_3$ conversion.} Consider $x \in \Z_2^l$. Given a sharing $\share{x}$ over $\Z_2$, the goal is to convert to a sharing of the same $x$ but over $\Z_3$. For this, the dealer provides the parties with a shares of a random bit-vector $\tilde{x} \in \Z_2^l$ over $\Z_2$, and shares of the same vector $r = \tilde{x}$, but over $\Z_3$. The conversion protocol now works as follows. First the parties locally add their shares to get $\share{\hat{x}} = \share{x} + \share{\tilde{x}} \bmod 2$. The parties then reconstruct $\hat{x}$ by exchanging their shares. Now, a $\Z_3$ sharing of $x^* \in \Z_3^l; x^* = x$ can be computed as:

    \[
        \share{x^*} = \share{\hat{x}} + \share{r} + (\hat{x} \odot \share{r}) \bmod 3
    \]
    where $\odot$ denotes the Hammard (element-wise) product modulo 3.

    \item \textbf{$\Z_3 \to \Z_2$ conversion.}
    Consider $x \in \Z_3^l$. Given a sharing $\share{x}$ over $\Z_3$, the goal is to convert to a sharing over $\Z_2$ of $x^* = x \bmod 2$. For this, the dealer provide the parties with the following correlated randomness. First it samples a random $\Z_3$ vector $\tilde{x}$ as a mask for $x$. It then computes $u = \tilde{x} \bmod 2$ and $v = (\tilde{x} + \textbf{1}^l \bmod 3) \bmod 2$ where $\textbf{1}^l$ is the all-ones vector of length $l$. Finally, the dealer provides the sharings $\share{x}$ (over $\Z_3$), $\share{u}$ (over $\Z_2$) and $\share{v}$ (over $\Z_2$) to the parties.

    \hspace*{1em} Now, the conversion protocol works as follows: First, the parties compute the sharing $\share{\hat{x}} = \share{x} + \share{\tilde{x}}$, and then exchange their shares to reconstruct $\share{\hat{x}}$.

\end{itemize}


\subsubsection{Applications.}


\newpage
